'''

재귀 함수를 언제 써야 하는가? => N중 반복문이 필요할 때
N이 안 정해져 있을 때 사용한다
문제가 작은 문제로 분할할 수 있을 때
대표적인 재귀 접근 방식 : 분할 정복
디버깅하기
언제 재귀 함수에서 return을 써야 할까?
작은 문제들의 결과를 큰 문제에서 합쳐야 할 때

한번 계산해 놓은 결과를 저장해 두고, 중복 계산을 피하자
저장된 결과를 재활용하여 중복 계산을 피하자

Memoization(top down) , 점화식을 구현하는 것 (bottom up)


어떻게 문제에 접근하는 게 좋을까?
=>
0. 문제를 잘 읽어야 한다 (계약서)
- 숨겨진 규칙들이 없는가??
1. 완전 탐색
- 단순 반복문 + 조건문으로 구현이 가능한가?
- 재귀 호출로 모든 경우를 본다면?

2. 규칙성을 찾는다.
- 문제에 숨겨진 규칙이나 패턴이 있는가? (예시를 보자)
- 순간마다 최선의 선택이 정답이다 (greedy)

3. 재계산을 하지 말자
- 중복되는 문제의 결과를 저장해놓고 재활용하자 (DP)

관계가 있다면 그래프
4. 전체 노드를 탐색하자
- DFS( 가능한 경우 끝까지 탐색하면서 나아가자)
- BFS (내 기준으로 퍼져나가면서 탐색하자)
N이 너무 큰 경우 :
새로운 알고리즘이나 자료구조를 고민해야 하는 단계

### 알고리즘
5. 재귀 호출 접근 법의 경우
- 백트래킹 (가지치기 ) : 더 이상 보지 않아도 되는 경우는 보지 말자
6. 정렬 (sort)
- 최소값 / 구간, 최대값/ 구간 등
- 내장 함수 sort() - O(NlogN)이 보장됨
- 탐색해야 한다면 이진 탐색을 볼 수 있다

7. 심화 문제들
- 최단거리  : dijkstra
- 최소 비용 : MST

### 자료 구조
- 한 번 만들어 놓고 여러 번 조회한다.
- 이진 탐색 트리
- 힙 (우선순위 큐 )
- 그룹화 (Union - Find)
- Trie, segment tree 등

'''

# for i in range(1, 4):
#     for j in range(1, 4):
#         print(i,j)

def KFC(num):
    if num ==2: # 기저 조건
        return
    # 재귀 호출 전에 들어가야 할 로직
    KFC(num+1)# 다음 재귀 호출 (매개 변수를 변경하면서 전달하는 역할)
    KFC(num+1)# 돌아오면서 해야 할 로직
    KFC(num+1)
    print(num)
# KFC(0)
# print("끝")
def KFC(x):
    if len(x) == 2:
        print(*x)
        return
    for i in range(1,4):
        KFC(x + [i])

KFC([])